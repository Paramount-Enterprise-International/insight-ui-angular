name: Build & Publish @insight/ui from Release Tag

on:
  release:
    types: [published]

env:
  LIB_NAME: insight-ui
  BUILD_BRANCH: build
  MAIN_BRANCH: main

permissions:
  contents: write

jobs:
  release-build:
    runs-on: ubuntu-latest

    steps:
      # 1) Checkout source at the tag created by your Release
      - name: Checkout source at tag
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}
          fetch-depth: 0

      # 2) Extract version from tag
      - name: Extract version from tag
        id: version
        shell: bash
        run: |
          TAG="${{ github.event.release.tag_name }}"
          echo "Tag from release: $TAG"

          if [[ ! "$TAG" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Tag '$TAG' does not look like x.y.z (e.g. 1.0.2)."
            exit 1
          fi

          echo "version=$TAG" >> "$GITHUB_OUTPUT"

      # 3) Set up Node
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      # 4) Install deps
      - name: Install dependencies
        shell: bash
        run: |
          rm -rf node_modules package-lock.json
          npm install

      # 5) Sync library version to tag (source metadata only; dist will be patched too)
      - name: Sync library version to tag
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Setting projects/${LIB_NAME}/package.json version to ${VERSION}"

          jq ".version = \"${VERSION}\"" "projects/${LIB_NAME}/package.json" > "projects/${LIB_NAME}/package.tmp"
          mv "projects/${LIB_NAME}/package.tmp" "projects/${LIB_NAME}/package.json"

          echo "Updated projects/${LIB_NAME}/package.json:"
          cat "projects/${LIB_NAME}/package.json"

      # 6) Build Angular library
      - name: Build Angular library
        shell: bash
        run: |
          npx --yes @angular/cli@20 build "$LIB_NAME" --configuration=production

      # 6.5) Inspect the generated dist package metadata (helps debug NF bundler issues)
      - name: Inspect built package metadata
        shell: bash
        run: |
          echo "=== dist/${LIB_NAME} tree (top) ==="
          ls -la "dist/${LIB_NAME}" || true
          echo
          echo "=== dist/${LIB_NAME}/package.json ==="
          cat "dist/${LIB_NAME}/package.json" || true
          echo
          echo "=== dist/${LIB_NAME}/fesm2022 (if exists) ==="
          ls -la "dist/${LIB_NAME}/fesm2022" || true

      # 6.6) Patch dist package.json to be Native-Federation-friendly
      # - sets version to release tag (guarantees dist metadata matches)
      # - ensures ESM-first ("type": "module")
      # - removes wildcard exports ("./*") which often triggers esbuild recursion
      # - keeps "." and any explicit secondary exports that are NOT wildcards
      - name: Patch dist package.json for Native Federation
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          PKG="dist/${LIB_NAME}/package.json"

          if [ ! -f "$PKG" ]; then
            echo "ERROR: $PKG not found"
            exit 1
          fi

          node - <<'NODE'
          const fs = require('fs');

          const pkgPath = process.env.PKG_PATH;
          const version = process.env.VERSION;

          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));

          // Ensure dist version matches the release tag
          pkg.version = version;

          // Ensure it's treated as ESM by tooling (helps esbuild/native federation)
          pkg.type = 'module';

          // Remove wildcard exports that can cause resolver recursion / stack overflow
          if (pkg.exports && pkg.exports['./*']) {
            delete pkg.exports['./*'];
          }

          // If exports exists, keep "." plus any explicit (non-wildcard) entries
          if (pkg.exports && typeof pkg.exports === 'object') {
            const safe = {};
            if (pkg.exports['.']) safe['.'] = pkg.exports['.'];

            for (const k of Object.keys(pkg.exports)) {
              if (k === '.') continue;
              if (k.includes('*')) continue;          // no wildcards
              safe[k] = pkg.exports[k];               // keep explicit secondaries
            }

            pkg.exports = safe;
          }

          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2));
          console.log('âœ… Patched', pkgPath);
          console.log(fs.readFileSync(pkgPath, 'utf8'));
          NODE
        env:
          PKG_PATH: dist/${{ env.LIB_NAME }}/package.json
          VERSION: ${{ steps.version.outputs.version }}

      # 7) Stash dist output OUTSIDE the repo (so cleaning can't delete it)
      - name: Stash build artifacts to runner temp
        shell: bash
        run: |
          ART_DIR="${RUNNER_TEMP}/insight-ui-build"
          rm -rf "$ART_DIR"
          mkdir -p "$ART_DIR"

          echo "Expecting dist at: dist/${LIB_NAME}"
          ls -la dist || true
          ls -la "dist/${LIB_NAME}" || true

          if [ ! -d "dist/${LIB_NAME}" ]; then
            echo "ERROR: dist/${LIB_NAME} not found. Build output path mismatch."
            exit 1
          fi

          cp -R "dist/${LIB_NAME}/." "$ART_DIR/"
          echo "Artifacts stashed to $ART_DIR:"
          ls -la "$ART_DIR"

      # âœ… 7.5) RESET repo so we can switch branches
      - name: Reset workspace to allow branch switch
        shell: bash
        run: |
          echo "Resetting workspace (discard changes) before switching branches..."
          git reset --hard
          git clean -fdx

      # 8) Switch to build branch (force-safe)
      - name: Checkout or create build branch
        shell: bash
        run: |
          git fetch origin "${BUILD_BRANCH}" || true

          # If build exists remotely, switch to it; otherwise create it
          if git ls-remote --exit-code --heads origin "${BUILD_BRANCH}" >/dev/null 2>&1; then
            git switch -C "${BUILD_BRANCH}" "origin/${BUILD_BRANCH}"
          else
            git switch -c "${BUILD_BRANCH}"
          fi

      # 9) Clean build branch workspace (tracked + untracked)
      - name: Clean build branch workspace
        shell: bash
        run: |
          echo "Cleaning build branch workspace..."
          git rm -rf . || true
          git clean -fdx

      # 10) Copy artifacts from runner temp into branch root
      - name: Copy artifacts into build branch
        shell: bash
        run: |
          ART_DIR="${RUNNER_TEMP}/insight-ui-build"

          echo "Copying artifacts from $ART_DIR into branch root..."
          if [ ! -d "$ART_DIR" ]; then
            echo "ERROR: Artifact dir missing: $ART_DIR"
            exit 1
          fi

          cp -R "$ART_DIR/." .

          echo "Resulting tree on build branch:"
          ls -la

          # Safety: ensure we did not publish source folders
          rm -rf node_modules release-tmp dist projects src || true

          # Safety: make sure package.json exists at root of build branch
          if [ ! -f "package.json" ]; then
            echo "ERROR: package.json missing in published artifact root (expected from dist output)."
            exit 1
          fi

      # 11) Commit & push build branch
      - name: Commit and push build branch
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add .
          if git diff --cached --quiet; then
            echo "ðŸŸ¡ No changes to commit on ${BUILD_BRANCH}"
          else
            git commit -m "release: @insight/ui v${VERSION}"
            git push origin "${BUILD_BRANCH}" --force
          fi

      # 12) Move version tag + latest to this build commit
      - name: Update tags to point at built artifacts
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          git fetch --tags origin

          git tag -f "$VERSION"
          git push origin "$VERSION" --force

          git tag -f latest
          git push origin latest --force

      # 13) Merge release source branch back into main (optional)
      - name: Merge release source branch back into main
        shell: bash
        run: |
          SRC_REF="${{ github.event.release.target_commitish }}"
          MAIN_BRANCH="${{ env.MAIN_BRANCH }}"

          echo "Release target_commitish: $SRC_REF"
          echo "Main branch: $MAIN_BRANCH"

          if [ "$SRC_REF" = "$MAIN_BRANCH" ]; then
            echo "Release source is already '$MAIN_BRANCH'. Nothing to merge."
            exit 0
          fi

          git fetch origin "$MAIN_BRANCH"

          if git ls-remote --exit-code origin "$SRC_REF" >/dev/null 2>&1; then
            git fetch origin "$SRC_REF":"$SRC_REF"
          fi

          git switch -C "$MAIN_BRANCH" "origin/$MAIN_BRANCH"
          git merge --no-ff "$SRC_REF" -m "chore: merge release $SRC_REF into $MAIN_BRANCH"
          git push origin "$MAIN_BRANCH"
